enum AirNetwork {
  ARBITRUM_ONE
  ARWEAVE_MAINNET
  AURORA
  AVALANCHE
  BOBA
  BSC # aka BNB Chain
  CELO
  COSMOS
  CRONOS
  MAINNET # Ethereum Mainnet
  FANTOM
  FUSE
  HARMONY
  JUNO
  MOONBEAM
  MOONRIVER
  NEAR_MAINNET
  OPTIMISM
  OSMOSIS
  MATIC # aka Polygon
  XDAI # aka Gnosis Chain
}

enum AirProtocolType {
  GENERIC
  EXCHANGE
  LENDING
  YIELD
  BRIDGE
  DAO
  NFT_MARKET_PLACE
  DOMAIN
  STAKING
  P2E #play to earn
  LAUNCHPAD
}

type AirBlock @entity {
 id: ID! #chain-number
 hash: String!
 number: BigInt!
 timestamp: BigInt!
}

type AirMeta @entity {
  id: ID! # air_meta 
  network: String!
  schemaVersion: String!
  slug: String! #Opensea_V1
  name: String! # Opeasea V1
	version: String!
}

type AirEntityCounter @entity {
	id: ID! #Air_DAILY_STATS_ACCOUNT
	count: BigInt!
	createdAt: AirBlock! 
	lastUpdatedAt: AirBlock!
}

type AirAccount @entity {
  id: ID!
  address: String!
	createdAt: AirBlock! 
}

type Domain @entity {
  id: ID!                                               # The namehash of the name
  name: String                                          # The human readable name, if known. Unknown portions replaced with hash in square brackets (eg, foo.[1234].eth)
  labelName: String                                     # The human readable label name (imported from CSV), if known
  labelhash: Bytes                                      # keccak256(labelName)
  tokenId: String!                                      # dec(labelHash)
  parent: Domain                                        # The namehash (id) of the parent name
  subdomains: [Domain!]! @derivedFrom(field: "parent")  # Can count domains from length of array
  subdomainCount: Int!                                  # The number of subdomains
  resolvedAddress: AirAccount                           # Address logged from current resolver, if any
  isPrimary: Boolean!
  owner: AirAccount!
  resolver: Resolver
  ttl: BigInt
  createdAt: AirBlock!
	lastBlockNumber: AirBlock!
}

interface AirDomainEvent {
  blockNumber: AirBlock!
  transactionHash: String!
  tokenId: String! # dec(labelhash) 
  domain: Domain!
  index: BigInt!
}

type AirDomainTransferTransaction implements AirDomainEvent @entity {
  id: ID!
  from: AirAccount!
  to: AirAccount!
  blockNumber: AirBlock!
  transactionHash: String!
  tokenId: String! # dec(labelhash) 
  domain: Domain!
  index: BigInt!
}

type AirDomainOwnerChangedTransaction implements AirDomainEvent @entity {
  id: ID!
  previousOwner: AirAccount!
  newOwner: AirAccount!
  blockNumber: AirBlock!
  transactionHash: String!
  tokenId: String! # dec(labelhash) 
  domain: Domain!
  index: BigInt!
}

type AirDomainNewResolverTransaction implements AirDomainEvent @entity {
  id: ID!
  previousResolver: AirAccount!
  newOwnerResolver: AirAccount!
  blockNumber: AirBlock!
  transactionHash: String!
  tokenId: String! # dec(labelhash) 
  domain: Domain!
  index: BigInt!
}

type AirDomainNewTTLTransaction implements AirDomainEvent @entity {
  id: ID!
  oldTTL: BigInt!
  newTTL: BigInt!
  blockNumber: AirBlock!
  transactionHash: String!
  tokenId: String! # dec(labelhash) 
  domain: Domain!
  index: BigInt!
}

interface AirDomainRegistration  {
  cost: BigInt!
  paymentToken: AirAccount!
  registrant: AirAccount!
  expiryBlock: AirBlock!
  registrationBlock: AirBlock!
}

type AirNameRegisteredTransaction implements AirDomainEvent & AirDomainRegistration @entity {
  id: ID!
  blockNumber: AirBlock!
  transactionHash: String!
  tokenId: String! # dec(labelhash) 
  domain: Domain!
  index: BigInt!
  cost: BigInt!
  paymentToken: AirAccount!
  registrant: AirAccount!
  expiryBlock: AirBlock!
  registrationBlock: AirBlock!
}

type AirNameRenewedTransaction implements AirDomainEvent & AirDomainRegistration @entity {
	id: ID!
  blockNumber: AirBlock!
  transactionHash: String!
  tokenId: String! # dec(labelhash) 
  domain: Domain!
  index: BigInt!
  cost: BigInt!
  paymentToken: AirAccount!
  registrant: AirAccount!
  expiryBlock: AirBlock!
  registrationBlock: AirBlock!
}

type AirPrimaryDomainTransaction implements AirDomainEvent @entity {
  id: ID!
  resolverAddress: String! #make sure toremove the old primary ens if changed
  blockNumber: AirBlock!
  transactionHash: String!
  tokenId: String! # dec(labelhash) 
  domain: Domain!
  index: BigInt!
}