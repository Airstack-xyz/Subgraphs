type AirBlock @entity {
    id: ID! #chain-number
    hash: String!
    number: BigInt!
    timestamp: BigInt!
}

type AirMeta @entity {
    id: ID! # air_meta
    network: String!
    schemaVersion: String!
    slug: String! #Opensea_V1
    name: String! # Opeasea V1
    version: String!
}

type AirEntityCounter @entity {
    id: ID!
    count: BigInt!
    createdAt: AirBlock!
    lastUpdatedAt: AirBlock!
}

type AirExtra @entity {
    id: ID! # Concatenation of domainId and name
    name: String!
    value: String!
}

type AirAccount @entity {
    id: ID!
    address: String!
    createdAt: AirBlock!
}

type AirToken @entity {
    id: ID!
    address: String!
}

type AirDomainAccount @entity {
    "The unique identifier for the account"
    id: ID!
    account: AirAccount!
    "domains resolved to this account"
    resolved: [AirDomain!] # this array will be used for isPrimary change
    "The domains owned by the account / manager of domain"
    manager: [AirDomain!]! @derivedFrom(field: "manager")
    "domains registered under this account / actual owner of domain(nft)"
    owner: [AirDomain!]! @derivedFrom(field: "owner")
}

type AirReverseRegistrar @entity {
    "ens name hash"
    id: ID!
    name: String!
    domain: AirDomain!
}

type AirDomain @entity {
    "The namehash of the name"
    id: ID!
    "The human readable name, if known. Unknown portions replaced with hash in square brackets (eg, foo.[1234].eth)"
    name: String
    "The human readable label name (imported from CSV), if known"
    labelName: String
    " keccak256(labelName)"
    labelHash: String
    " dec(labelHash)"
    tokenId: String
    "The namehash (id) of the parent name"
    parent: AirDomain
    "Can count domains from length of array"
    subdomains: [AirDomain!]! @derivedFrom(field: "parent")
    "The number of subdomains"
    subdomainCount: BigInt!
    "Address logged from current resolver, if any"
    resolvedAddress: AirDomainAccount
    "The account that manager the domain"
    manager: AirDomainAccount!
    "The account that owns the ERC721 NFT for the domain"
    owner: AirDomainAccount!
    "The resolver that controls the domain's settings"
    resolver: AirResolver
    "The time-to-live (TTL) value of the domain's records"
    ttl: BigInt
    "Is the primary domain for the resolved address"
    isPrimary: Boolean!
    "The expiry date for the domain, from either the registration, or the wrapped domain if PCC is burned"
    #expiryTimestamp: BigInt!
    #registrationCost: BigInt! # Cost of domain registration in wei
    #paymentToken: AirToken # Token used to pay for registration
    tokenAddress: AirToken # Domain (eg: ens) token contract address
    createdAt: AirBlock!
    lastUpdatedBlock: AirBlock #- NA
    registrationOrRenew: [AirDomainRegistrationOrRenew!]! @derivedFrom(field: "domain")
    lastUpdatedIndex: BigInt!
    "fuses set from namewrapper"
    fuses: BigInt!
    "name wrapped"
    isNameWrapped: Boolean!

    events: [AirDomainEvent!]! @derivedFrom(field: "domain")
}

type AirDomainRegistrationOrRenew @entity {
    "domainId +-+ hash"
    id: ID!
    "The unique identifier of the registration(label ?)"
    isRenew: Boolean
    "hash"
    hash: Bytes!
    "The domain name associated with the registration"
    domain: AirDomain!
    "The registration date of the domain"
    registrationDate: BigInt!
    "The expiry date of the domain"
    expiryDate: BigInt
    "The cost associated with the domain registration"
    cost: BigInt
    "The account that registered the domain"
    owner: AirDomainAccount!
    #"The human-readable label name associated with the domain registration"
    #labelName: String
    createdAt: AirBlock!

    lastUpdatedBlock: AirBlock #- NA
    lastUpdatedIndex: BigInt!
}

interface AirDomainEvent {
    "hash + logIndex"
    id: ID!
    "The registration associated with the event"
    domain: AirDomain!
    "The block number of the event"
    lastUpdatedBlock: AirBlock!

    "The transaction hash associated with the event"
    hash: Bytes!
}

type AirDomainNewResolver implements AirDomainEvent @entity {
    "hash + logIndex"
    id: ID!
    "The registration associated with the event"
    domain: AirDomain!

    "resolver"
    resolver: AirResolver!

    "The block number of the event"
    lastUpdatedBlock: AirBlock!

    "The transaction hash associated with the event"
    hash: Bytes!
}
type AirDomainNewTTL implements AirDomainEvent @entity {
    "hash + logIndex"
    id: ID!
    "The registration associated with the event"
    domain: AirDomain!

    "ttl"
    ttl: BigInt!

    "The block number of the event"
    lastUpdatedBlock: AirBlock!

    "The transaction hash associated with the event"
    hash: Bytes!
}

type AirDomainRegistered implements AirDomainEvent @entity {
    "hash + logIndex"
    id: ID!
    "The registration associated with the event"
    domain: AirDomain!

    "The account of new owner"
    owner: AirDomainAccount!

    "The block number of the event"
    lastUpdatedBlock: AirBlock!

    "The transaction hash associated with the event"
    hash: Bytes!
}

type AirDomainNameWrapped implements AirDomainEvent @entity {
    "hash + logIndex"
    id: ID!
    "The registration associated with the event"
    domain: AirDomain!

    "The account that registered the name"
    owner: AirDomainAccount!

    "The block number of the event"
    lastUpdatedBlock: AirBlock!

    "The transaction hash associated with the event"
    hash: Bytes!
}

type AirDomainNameUnwrapped implements AirDomainEvent @entity {
    "hash + logIndex"
    id: ID!
    "The registration associated with the event"
    domain: AirDomain!

    "The account that registered the name"
    owner: AirDomainAccount!

    "The block number of the event"
    lastUpdatedBlock: AirBlock!

    "The transaction hash associated with the event"
    hash: Bytes!
}

type AirDomainTransferred implements AirDomainEvent @entity {
    "hash + logIndex"
    id: ID!
    "The registration associated with the event"
    domain: AirDomain!

    "The account of new owner"
    newOwner: AirDomainAccount!

    "The account of old owner"
    oldOwner: AirDomainAccount!

    "The block number of the event"
    lastUpdatedBlock: AirBlock!

    "The transaction hash associated with the event"
    hash: Bytes!
}

type AirResolver @entity {
    "Concatenation of resolver address and namehash"
    id: ID!
    "The domain that this resolver is associated with"
    domain: AirDomain!

    "Address of resolver"
    resolverAddress: Bytes!

    "Address logged from current resolver, if any"
    resolvedAddress: AirDomainAccount

    "can save extra data like github,twitter,etc"
    extras: [AirExtra!]

    "to track multi chain addresses this domain points to"
    coinType: [AirDomainCoin!]! @derivedFrom(field: "resolver")

    createdAt: AirBlock!
    lastUpdatedBlock: AirBlock! #- NA
    lastUpdatedIndex: BigInt!
}

type AirDomainCoin @entity {
    "AirResolver id +-+coinType"
    id: ID!

    resolver: AirResolver!
    "coinType"
    coinType: BigInt!
    "address it points to"
    address: Bytes!
}

# mapping to fetch domainId of a label at a particular hash
type NewOwnerHashLabelMap @entity {
    "Concatenation of tx hash and label"
    id: ID!
    "The domain that this resolver is associated with"
    domainId: String!
}
" mapping used to identify if the data from controller can be used or not"
type RemovedController @entity {
    "address of removed controller"
    id: ID!
}

# book keeping entities

type PrimarySet @entity {
    id: ID!
    hash: Bytes!
    from: Bytes!
    name: String!
}

type ResolverEntity @entity {
    # Resolver
    id: ID!
}

type ControllerEntity @entity {
    # Controller
    id: ID!
    txHash: Bytes!
}

type ReverseRegistrarEntity @entity {
    # ReverseRegistrar
    id: ID!
    txHash: Bytes!
}

type ControllerNameWrapperEntity @entity {
    # Controller
    id: ID!
    txHash: Bytes!
}

type ControllerRemoved @entity {
    # Controller
    id: ID!
}

type ControllerNameWrapperRemoved @entity {
    # Controller
    id: ID!
}

type ResolvedAddressTxn @entity {
    id: ID!
    txHash: Bytes!
    node: Bytes!
    resolverAddress: Bytes!
    resolvedAddress: Bytes!
}

type MultiCoinTxn @entity {
    id: ID!
    txHash: Bytes!
    node: Bytes!
    resolverAddress: Bytes!
    newAddress: Bytes!
    coinType: BigInt!
}

type TextChangedTxn @entity {
    id: ID!
    txHash: Bytes!
    node: Bytes!
    resolverAddress: Bytes!
    key: String!
    value: String!
}
type FusesSetTxn @entity {
    id: ID!
    txHash: Bytes!
    node: Bytes!
    fuses: BigInt!
}
type InvalidName @entity {
    id: ID!
    name: String!
    label: Bytes!
    txHash: Bytes!
}
