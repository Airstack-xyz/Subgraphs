type AirBlock @entity {
    id: ID! #chain-number
    hash: String!
    number: BigInt!
    timestamp: BigInt!
}

type AirMeta @entity {
    id: ID! # air_meta
    network: String!
    schemaVersion: String!
    slug: String! #Opensea_V1
    name: String! # Opeasea V1
    version: String!
}

type AirEntityCounter @entity {
    id: ID!
    count: BigInt!
    createdAt: AirBlock!
    lastUpdatedAt: AirBlock!
}

type AirExtra @entity {
    id: ID! # Concatenation of domainId and name
    name: String!
    value: String!
}

type AirAccount @entity {
    id: ID!
    address: String!
    createdAt: AirBlock!
}

type AirToken @entity {
    id: ID!
    address: String!
}

type AirDomainAccount @entity {
    "The unique identifier for the account"
    id: ID!
    account: AirAccount!
    "domains resolved to this account"
    resolved: [AirDomain!] # this array will be used for isPrimary change
    "The domains owned by the account / manager of domain"
    manager: [AirDomain!]! @derivedFrom(field: "manager")
    "domains registered under this account / actual owner of domain(nft)"
    owner: [AirDomain!]! @derivedFrom(field: "owner")
}

type AirDomain @entity {
    "The namehash of the name"
    id: ID!
    "The human readable name, if known. Unknown portions replaced with hash in square brackets (eg, foo.[1234].eth)"
    name: String
    "The human readable label name (imported from CSV), if known"
    labelName: String
    " keccak256(labelName)"
    labelHash: String
    " dec(labelHash)"
    tokenId: String
    "The namehash (id) of the parent name"
    parent: AirDomain
    "Can count domains from length of array"
    subdomains: [AirDomain!]! @derivedFrom(field: "parent")
    "The number of subdomains"
    subdomainCount: BigInt!
    "Address logged from current resolver, if any"
    resolvedAddress: AirDomainAccount
    "The account that manager the domain"
    manager: AirDomainAccount!
    "The account that owns the ERC721 NFT for the domain"
    owner: AirDomainAccount!
    "The resolver that controls the domain's settings"
    resolver: AirResolver
    "The time-to-live (TTL) value of the domain's records"
    ttl: BigInt
    "Is the primary domain for the resolved address"
    isPrimary: Boolean!
    "The expiry date for the domain, from either the registration, or the wrapped domain if PCC is burned"
    #expiryTimestamp: BigInt!
    #registrationCost: BigInt! # Cost of domain registration in wei
    #paymentToken: AirToken # Token used to pay for registration
    tokenAddress: AirToken # Domain (eg: ens) token contract address
    createdAt: AirBlock!
    lastUpdatedBlock: AirBlock #- NA
    registration: AirDomainRegistration @derivedFrom(field: "domain")
    lastUpdatedIndex: BigInt!
    "fuses set from namewrapper"
    fueses: BigInt!
}

type AirDomainRegistration @entity {
    "The unique identifier of the registration(label ?)"
    id: ID!
    "The domain name associated with the registration"
    domain: AirDomain!
    "The registration date of the domain"
    registrationDate: BigInt!
    "The expiry date of the domain"
    expiryDate: BigInt
    "The cost associated with the domain registration"
    cost: BigInt
    "The account that registered the domain"
    owner: AirDomainAccount!
    #"The human-readable label name associated with the domain registration"
    #labelName: String
    createdAt: AirBlock!

    lastUpdatedBlock: AirBlock #- NA
    lastUpdatedIndex: BigInt!

    events: [AirDomainRegistrationEvent!]! @derivedFrom(field: "registration")
}

interface AirDomainRegistrationEvent {
    "hash + logIndex"
    id: ID!
    "The registration associated with the event"
    registration: AirDomainRegistration!
    "The block number of the event"
    lastUpdatedBlock: AirBlock

    "The transaction hash associated with the event"
    transactionHash: Bytes!
}

type AirDomainRegistered implements AirDomainRegistrationEvent @entity {
    "hash + logIndex"
    id: ID!
    "The registration associated with the event"
    registration: AirDomainRegistration!

    "The account that registered the name"
    registrant: AirDomainAccount!

    "The block number of the event"
    lastUpdatedBlock: AirBlock

    "The transaction hash associated with the event"
    transactionHash: Bytes!
}

type AirDomainRenewed implements AirDomainRegistrationEvent @entity {
    "hash + logIndex"
    id: ID!
    "The registration associated with the event"
    registration: AirDomainRegistration!

    "The account that renewed the name"
    renewer: AirDomainAccount!

    "The block number of the event"
    lastUpdatedBlock: AirBlock

    "The transaction hash associated with the event"
    transactionHash: Bytes!
}

type AirDomainTransferred implements AirDomainRegistrationEvent @entity {
    "hash + logIndex"
    id: ID!
    "The registration associated with the event"
    registration: AirDomainRegistration!

    "The account of new owner"
    newOwner: AirDomainAccount!

    "The account of old owner"
    oldOwner: AirDomainAccount!

    "The block number of the event"
    lastUpdatedBlock: AirBlock

    "The transaction hash associated with the event"
    transactionHash: Bytes!
}

type AirResolver @entity {
    "Concatenation of resolver address and namehash"
    id: ID!
    "The domain that this resolver is associated with"
    domain: AirDomain!

    "Address of resolver"
    resolverAddress: Bytes!

    "Address logged from current resolver, if any"
    resolvedAddress: AirDomainAccount

    "can save extra data like github,twitter,etc"
    extras: [AirExtra!]

    "to track multi chain addresses this domain points to"
    coinType: [AirDomainCoin!]! @derivedFrom(field: "resolver")

    address: Bytes! # Address of resolver contract
    createdAt: AirBlock!
    lastUpdatedBlock: AirBlock! #- NA
    lastUpdatedIndex: BigInt!
}

type AirDomainCoin @entity {
    "AirResolver id +-+coinType"
    id: ID!

    resolver: AirResolver!
    "coinType"
    coinType: BigInt!
    "address it points to"
    address: Bytes!
}

# mapping to fetch domainId of a label at a particular hash
type NewOwnerHashLabelMap @entity {
    "Concatenation of tx hash and label"
    id: ID!
    "The domain that this resolver is associated with"
    domainId: String!
}
" mapping used to identify if the data from controller can be used or not"
type RemovedController @entity {
    "address of removed controller"
    id: ID!
}

# book keeping entities

interface DomainEvent {
    "The unique identifier of the event"
    id: ID!
    "The domain name associated with the event"
    domain: String!
    "The block number at which the event occurred"
    blockNumber: Int!
    "The transaction hash of the transaction that triggered the event"
    txHash: Bytes!
}

type Transfer implements DomainEvent @entity {
    "The unique identifier of the event"
    id: ID!
    "The domain name associated with the event"
    domain: String!
    "The block number at which the event occurred"
    blockNumber: Int!
    "The transaction hash of the transaction that triggered the event"
    txHash: Bytes!
    "The account that owns the domain after the transfer"
    owner: String!
}

type NewOwner implements DomainEvent @entity {
    "The unique identifier of the event"
    id: ID!
    "The parent domain of the domain name associated with the event"
    parentDomain: String!
    "The domain name associated with the event"
    domain: String!
    "The block number at which the event occurred"
    blockNumber: Int!
    "The transaction hash of the transaction that triggered the event"
    txHash: Bytes!
    "The new account that owns the domain"
    owner: String!
}

type NewResolver implements DomainEvent @entity {
    "The unique identifier of the event"
    id: ID!
    "The domain name associated with the event"
    domain: String!
    "The block number at which the event occurred"
    blockNumber: Int!
    "The transaction hash of the transaction that triggered the event"
    txHash: Bytes!
    "The new resolver contract address associated with the domain"
    resolver: String!
}

type NewTTL implements DomainEvent @entity {
    "The unique identifier of the event"
    id: ID!
    "The domain name associated with the event"
    domain: String!
    "The block number at which the event occurred"
    blockNumber: Int!
    "The transaction hash of the transaction that triggered the event"
    txHash: Bytes!
    "The new TTL value (in seconds) associated with the domain"
    ttl: BigInt!
}

type ControllerAddedEvent @entity {
    "The unique identifier of the event"
    id: ID!
    "controller from event params"
    controller: Bytes!
    "baseRegistrar address"
    baseRegistrar: Bytes!
    "The block number at which the event occurred"
    blockNumber: Int!
    "The transaction hash of the transaction that triggered the event"
    txHash: Bytes!
}

type ControllerRemovedEvent @entity {
    "The unique identifier of the event"
    id: ID!
    "controller from event params"
    controller: Bytes!
    "baseRegistrar address"
    baseRegistrar: Bytes!
    "The block number at which the event occurred"
    blockNumber: Int!
    "The transaction hash of the transaction that triggered the event"
    txHash: Bytes!
}

type PrimarySet @entity {
    id: ID!
    hash: Bytes!
    name: String!
}

type ReverseRegistrar @entity {
    id: ID!
}
